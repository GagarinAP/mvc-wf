
Автор: Sergio.Lesnik@gmail.com

Теперь основное место жительста проекта:
https://github.com/lesnikyan/mvc-wf


---
1. Чтоэта?
	Это имитация MVC веб-фреймворка, или MVC фреймворк минимальной комплектации.
	Upd. Название главного класса было заменено с Core на Wf (Web Framework), 
	так и короче, и больше соответствует назначению.

2. Состав:
---
	a) Ядро системы (класс Wf), выполняющее функцию единого контейнера системных классов, 
		логики исполнения, интерфейса конфигурационного "словаря" и фабрики основных объектов: шаблонов, моделей. 
		Ядро содержит все ключевые объекты, включая статический экземпляр-синглтон класса Wf 
		и предоставляет интерфейс к удобному их использованию путем вызова статических методов. 
		Полный список методов см. в конце.
		Подробные описания методов см. по темам.
---	
	b) Маршрутизатор (роутер), позволяющий работать с урлами вида /sermeng1/segment2/.../segmentN
		Где segment1 - определяет целевой контроллер, а
		segment2 - целевой метод контроллера.
		Остальные сегменты передаются как параметры вызываемого метода
		В рамках Wf роутер доступен как self::$router;
		Может использоваться как перенаправление в .htaccess, 
		так и прямой вызов скрипта index.php, путь от имени домена к index.php (включительно) 
		принимается как базовый путь сайта (base_path). все, что содержится за ним используется маршрутизатором для построения вызова целевого кода.

	b2) Расширенная маршрутизация. Осуществляется путем описания необходимых перенаправлений при помощи объектов-правил.
		Каждое правило описывает некотрый случай, используемый роутером при совпадении с правилом. 
		Правила перебираются последовательно, в порядке объявления в конфиге.
		Каждое правило - экземпляр объекта, имплементирующего интерфейс RoutingRule.
		В готовом виде предоставляется класс правил, управляемых регулярными выражениями: RoutingRegexRule.
		Параметры конструктора RoutingRegexRule: 
		$rule - регулярное выражение с группами (в скобках).
		$role - преобразование частей url в список маршрутизации: контроллер, метод, параметры.
		Пример: new RoutingRegexRule('#^/user-info/(\d+)$#Ui', ['c'=>'user_utils', 'm' => 'info', 'p1' => 1])
		Ссылка "http://domain.com/user-info/123" вызовет в контроллере `User_utils` метод `info` с параметром: `123`.
		Использование правил включается в конфиге ['routing.use_rules' => true], 
		список правил указывается там же в ['routing.rules' => [new RoutingRule()]]
---	
	c) Конфиг. На данный момент - ассоциативный массив $config, загружаемый из /config.php , и хранящийся в свойстве $conf ядра. 
		Метод Wf::conf('key') предоставляет глобальный доступ на чтение параметров конфигурации.
---	
	d) Controller - базовый класс контроллера. 
		Конкретный контроллер - класс-потомок Controller-а, представляющий некоторый контекст, 
		как правило, отвечающий за тематический функционал или раздел верхнего уровня сайта. 
		Класс содержит набор методов, реализующих весь необходимый функционал. 
		В общем случае, контроллеру соответствует первый сегмент URL , методу контроллера - второй сегмент. 
		Остальные сегменты передаются в метод контроллера как его параметры при вызове.
	Код контроллера физически находится в файле с именем контроллера, 
		например users.php для 'domain.com{/base_path}/users/', в директории /application/controller/ . 
		В итоге, для урла /users/view/123/ будет загружен соотв. файл и создан экземпляр класса UsersController, 
		после чего вызван метод 'view' с указанным параметром. Условный аналог кода:  (new UsersController())->view(123).
	Если не указан первый сегмент - вызывается $conf['default_controller']. // main
	Если не указан второй сегмент - вызывается $conf['default_method']. // index
	Метод index() содержится в базовом классе и может переопределяться, как метод без параметров.
	
	e) View (представление). Нативный шаблонизатор, использующий "короткий" синтаксис php в файлах шаблонов. 
		Экземпляр шаблонизатора создается статическим методом Wf::view, 
		в качестве параметров передаются имя шаблона и ассоциативный массив связанных значений: 
		$view = Wf::view('main', array('title' => 'Hello user!')).
	Каждая пара из массива значений будет при выполнении шаблона преобразована в соотв. переременую шаблона:
	<h1><?= $title?></h1>
	
	Альтернативный способ установки значений переменных шаблонизатора - создание полей экземпляра View после его создания:
		$view = Wf::view('main', $data);
		$view->title = 'Hello page!';
		Фактически тут вызывается __set() метод класса View.

		Методы шаблонизатора:
		$view->setData($data); // устанавливает новый набор связанных значений, удаляя предыдущий.
		$view->render(boolean $output = false); // выполняет шаблон, возвращая сгенерированный HTML (или иной код) в виде строки. 
			Необязательный параметр $output указывает шаблонизатору отправить сгенерированный код в поток вывода.

	Upd.
	В шаблонизатор добавлена возможность импортировать дочерние шаблоны.
	<? $this->import('name/of/template', ['sub_name' => 'Part 3'])?>
	Параметры указываются аналогично методу Wf::view(). При этом переменные, установленные для родительского шаблона,
доступны в дочернем. 
	Переменные, объявленные в ходе выполнения родительского шаблона (например в цикле), автоматически в дочерний не передаются, 
т.е., при необходимости, нужно их объявить во втором параметре метода ->import.
---
	f) Model (модель). Базовый класс для моделей. Модели создаются статическим методом ядра Wf::model('имя_модели'). 
	Физически файлы моделей находятся в директории /applications/models/.
	Имя файла соответствует имени модели, Класс модели имеет суффикс 'Model', начинается с большой буквы.
	Wf::model('users') -->> new UsersModel();
	В конструкторе модели должен быть вызван parent::__constructor($tableName).
	В качестве параметра передается имя целевой таблицы БД.
	
	Методы модели:
	$model->create($data); // создает запись по списку значений полей $data = ['field' => 'value', ..]
	$model->read($id); // возвращает строку из БД по ид.
	$model->update($id, $data); // изменяет строку в БД по ид.
	$model->delete($id); // удаляет запись по ид.
	$model->all(int $from=0, int $limit=100, boolean $objectFormat=true, string $order='ASC'); // выводит список строк, по указанным ограничениям. 
	параметр $objectFormat управляет форматом вывода строк (true ? object : array)
	
	Внутреннее свойство модели $this->db - экземпляр класса MysqlDriver 
	( в случае, если не был добавлен другой, и установлен в параметрах опций БД в конфиге). 
	MysqlDriver - расширение класса PDO, набором методов, удобных для вызова типичных SQL-запросов. Методы:
	
		параметры: 
		$sql - sql запрос, составленный по правилам параметризованных запросов 
		$data - массив значений, соответствующий параметризованному запросу $sql
		$format - определяет формат результата (true ? object : array)
	->select($sql, $data=array(), $format=true); // возвращает список значений. 
	->insert($sql, $data=array());	// возвращает ИД добавленной записи
	->update($sql, $data=array()); // возвращает количество измененных строк
	->delete($sql, $data=array()); // взыращает количество удаленных строк

---	
	2. Общая стратегия использования.
		1. Добавление нового функционала. Первым делом, добавляется новый контроллер. 
		По мере расширения функционала контроллера, в него добавляются методы. 
		Хорошей практикой будет выносить общий для контекста контроллера функционал в приватные методы класса.
		
		2. Для каждого контроллера может создаваться любое количчество представлений/шаблонов (view). 
		Хорошей практикой было бы группировать шаблоны по директориям с именем контроллеров. 
		Экземпляр представления создается статическим методом ядра $view=Wf::view('имя/шаблона/как/путь'); 
		имя - путь внутри директории /application/views/ без расширения.
		
		3. Модели создаются по мере добавления новых ключевых таблиц в БД. 
		В общем случае, это совпадает с созданием нового контроллера. 
		Экземпляр модели создается статическим методом $model=Wf::model('имя_модели'); 
		имя соответствует имени файла без расширения.
		
		4. Для размещения статики и медиа-файлов используется паблик директория media в корневом каталоге. 
		Содержит подкаталоги для разных типов статики:
		/media
			/css
			/js
			/img
		Изменение публичных директорий для медиа-ресурсов допустимо. Но требует изменения файла .htaccess.
---	
	3. Структура файлов:
	
	index.php	-	стартовый скрипт.
	config.php	-	конфигурация проекта.
	README.txt	-	текстовый мануал.
	
	/lib	-	системные классы "ядра" фреймворка.
	
	/application	-	файлы приложения. (на данный момент содержит некоторое количество кода с примерами)
		/controllers
		/models
		/views
		
	/media		-	статический контент.
		/css
		/js
		/img
	

	4. Статические методы фреймворка Wf::
		instance - создает (при первом вызове) и возвращает актуальный синглтон-экземпляр объекта фреймворка Wf.
		conf - возвращает значение конфига по ключу
		view - возвращает экземпляр шаблонизатора по имени файла ('login/form')
		model - возвращает экземпляр модели данных
		get	- возвращает значение GET-параметра
		post - возвращает значение POST - параметра
		cache - возвращает экземпляр класса кеширования
		redirect - перенаправляет запрос на указанный url
		redirectTo - перенаправляет запрос на указанный локальный путь
		subUrl - создает url по локальному пути
		cookie - устанавливает и возвращает cookie
